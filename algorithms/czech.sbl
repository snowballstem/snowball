routines (
  R1
  palatalise_e
  palatalise_i
  mark_regions
  possessive_suffix
  case_suffix
)

externals ( stem )

integers ( p1 x )

groupings ( v v_or_syllabic_c )

stringescapes {}

stringdef a' '{U+00E1}' // á
stringdef cv '{U+010D}' // č
stringdef dv '{U+010F}' // ď
stringdef e' '{U+00E9}' // é
stringdef ev '{U+011B}' // ě
stringdef i' '{U+00ED}' // í
stringdef nv '{U+0148}' // ň
stringdef o' '{U+00F3}' // ó
stringdef rv '{U+0159}' // ř
stringdef sv '{U+0161}' // š
stringdef tv '{U+0165}' // ť
stringdef u' '{U+00FA}' // ú
stringdef uo '{U+016F}' // ů
stringdef y' '{U+00FD}' // ý
stringdef zv '{U+017E}' // ž

define v 'aeiouy{a'}{ev}{e'}{i'}{o'}{u'}{uo}{y'}'

// Some consonants in Czech can be syllabic - if these occur between two other
// consonants then they act in a vowel-like way and it is helpful to include
// them in the definition of R1.
//
// Some sources also list 'm' and 'n' as syllabic consonants for Czech but they
// seem to be much rarer and including them makes no difference to the results
// of stemming any words in our sample vocabulary list.  Checking on a larger
// vocabulary list (also from wikipedia but with a lower cut-off frequency)
// all but one of the affected words don't seem to actually be Czech words.
define v_or_syllabic_c v + 'lr'

define mark_regions as (

    test (hop 3 setmark x) // Signals f if the input < 3 characters.

    $p1 = limit
    do (
        // A syllabic consonant must occur between two consonants, or be
        // preceded by a consonant and at the end of the word.
        //
        // Instead of literally testing that, we handle the first character
        // specially by only checking if it's a vowel; for subsequent
        // characters we know that the character before is a consonant because
        // otherwise we'd have stopped already.
        //
        // We also don't actually need to check the character after, since
        // if it's a vowel then that vowel means we'd end up at the same
        // position after `gopast non-v` anyway, and if it's the end of the
        // word then there's no non-v after it.
        (v or (next gopast v_or_syllabic_c)) gopast non-v
        setmark p1
        try($p1 < x  $p1 = x)  // at least 3
    )
)

backwardmode (

  define R1 as $p1 <= cursor

  define palatalise_e as (
    [substring] among (
      'c' '{cv}' (<- 'k')
      'z' '{zv}' (<- 'h')
    )
  )

  define palatalise_i as (
    [substring] among (
      'c' '{cv}' (<- 'k')
      'z' '{zv}' (<- 'h')
      '{cv}t' (<- 'ck')
      // -št -> -sk
      '{sv}t' // e.g. čeština
        (<-'sk')
      '{a'}{sv}t' // e.g. plášti
      'de{sv}t' // e.g. dešti
      'i{sv}t' // e.g. bojišti
      '{i'}{sv}t' // e.g. příští
      'le{sv}t' // e.g. kleští
      'pou{sv}t' // e.g. poušti, spouští
        ()
    )
  )

  define possessive_suffix as (
    [substring] R1 among (
      'ov' '{uo}v'
      (delete)
      'in'
      (
        delete
        try palatalise_i
      )
    )
  )

  define case_suffix as (
    setlimit tomark p1 for ( [substring] ) among (
      'atech'
      'at{uo}m'
      '{a'}ch' '{y'}ch' 'ov{e'}' '{y'}mi'
      'ata' 'aty' 'ama' 'ami' 'ovi'
      'at' '{a'}m' 'us' '{uo}m' '{y'}m' 'mi' 'ou'
      '{e'}ho' '{e'}m' '{e'}mu'
      'u' 'y' '{uo}' 'a' 'o' '{a'}' '{e'}' '{y'}'
      (delete)
      '{ev}' '{ev}tem' '{ev}mi' '{ev}te' '{ev}ti'
      '{ev}m' // e.g. koněm
      (
        delete
      )
      'e' 'ech' 'em' 'emi' 'ete' 'etem'
      (
        delete
        try palatalise_e
      )
      'eb'
      ( // Conflate e.g. skladeb with skladba, skladbě, skladby, etc.
        // The correct linguistic root is the -eb form, but we map to -b as
        // that's easier to do reliably than to map the other way.
        test non-v
        not 't{rv}' // potřeb
        <-'b'
      )
      'ec'
      ( // Conflate e.g. obec with obce, obcemi, obci, obcí, obcích.
        // The correct linguistic root is the -ec form, but we map to -c as
        // that's easier to do reliably than to map the other way.
        test non-v
        delete attach 'c'
        try palatalise_e
      )
      'ek'
      ( // Conflate e.g. článek with článkem, článku, článků, článkům, články.
        // The correct linguistic root is the -ek form, but we map to -k as
        // that's easier to do reliably than to map the other way.
        test non-v
        not among (
          'dot' // dotek
          'obl' // oblek
          'sn' // česnek
        )
        <-'k'
      )
      'et'
      ( // Conflate e.g. počet with počte, počtu, počty, etc.
        // The correct linguistic root is the -et form, but we map to -t as
        // that's easier to do reliably than to map the other way.
        among (
          'uc' // e.g. tucet but not dvacet.
          '{cv}'
          'h'
          'ok' // e.g. loket but not paket.
          'kar' // e.g. karet but not cigaret.
        )
        <-'t'
      )
      '{tv}' '{tv}mi'
      ( // Conflate e.g. oběť and oběťmi with obětech; hradišť with hradišti.
        <-'t'
      )
      'i'
      '{i'}' '{i'}ch' '{i'}ho' '{i'}m' '{i'}mi' '{i'}mu'
      (
        delete
        try palatalise_i
      )
    )
  )
)

define stem as (
  mark_regions // Signals f if the input has < 3 characters.
  backwards (
    do case_suffix
    do possessive_suffix
  )
)

// Ljiljana Dolamic and Jacques Savoy. 2009.
// Indexing and stemming approaches for the Czech language.
// Inf. Process. Manage. 45, 6 (November 2009), 714-720.
// based on Java code by Ljiljana Dolamic:
// http://members.unine.ch/jacques.savoy/clef/CzechStemmerLight.txt
